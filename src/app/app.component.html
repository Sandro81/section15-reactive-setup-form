
<div class="container">
  <div class="row">
    <div class="col">
      <form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
        <div class="form-group">
          <label for="username">Username</label>
          <input
            type="text"
            id="username"
            formControlName="username"
            class="form-control">
        </div>
        <div class="form-group">
          <label for="email">email</label>
          <input
            type="text"
            id="email"
            class="form-control"
            name="email">
        </div>
        <div class="radio" *ngFor="let gender of genders">
          <label>
            <input
              type="radio"
              name="gender"
              [value]="gender">{{ gender }}
          </label>
        </div>
        <button class="btn btn-primary" type="submit">Submit</button>
      </form>
    </div>
  </div>
</div>

<hr>

<div class="container">
  <div class="row">
    <div class="col">
      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson 200. Reactive: Setup </h5>
          <p class="card-text"> Now as I said, in the reactive approach, the form is created programmatically. </p>
          <p class="card-text">We need to import <code>import &#123;FormGroup} from '@angular/forms';</code></p>
          <p class="card-text">We need also to import into the app.module <code>import &#123;ReactiveFormsModule} from '@angular/forms';<br>
            imports: [<br>
            BrowserModule,<br>
            <b>ReactiveFormsModule</b><br>
            ],<br></code></p>
        </div>
      </div>

      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson 201. Reactive: Creating a Form in Code </h5>
          <p class="card-text"> You should initialize it before rendering the template of course, so make sure to use a lifecycle hook which is called before the template is rendered. Here I will set up my signupForm and I will set it equal to, to what? Well keep in mind, signupForm is of type FormGroup, so we need to create a new FormGroup here, just like this. Now we have almost a valid form, we need to pass a Javascript object here and we're theoretically done, this is our first created form. This Javascript object configures it and as it's empty, it simply says or it tells Angular. <code>ngOnInit(): void &#123;<br>
            this.signupForm = new FormGroup(&#123;});<br>
            }</code></p>
          <p class="card-text">      I should say. So I will set up or create a new FormControl here and FormControl should also be added from the forms package, from @angular/forms. Now to this FormControl constructor, we can pass a couple of arguments, the first argument is the initial state, the initial value of this control you could say. The second argument will be a single validator or an array of validators we want to apply to this control, I'll come back to this. The third argument will be potential asynchronous validators, I will also come back to this later.
            <br><code> ngOnInit(): void &#123;<br>
              this.signupForm = new FormGroup(&#123;<br>
              'username': new FormControl(null),<br>
              'email': new FormControl(null),<br>
              'gender': new FormControl('male'),<br>
              });<br>
              }</code></p>
        </div>
      </div>

      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson 202. Reactive: Syncing HTML and Form</h5>
          <p class="card-text">  Now this simply tells Angular, hey please take my formGroup, don't infer one, don't create a form for me, use my formGroup and we need to set up property binding here because we need to pass our form as an argument to the directive. <code>      &#60;form [formGroup]="signupForm"></code> signupForm is the reference to the app.component.ts <code> signupForm: FormGroup;</code></p>
          <p class="card-text">We're passing this via property binding to the formGroup and now this form is actually synchronized with the form we created in TypeScript but we still need to tell Angular which controls should be connected to which inputs in the template code, for this we get another directive. Well the name is username, this name here because that's the control I want to connect to this input, so I simply pass username here. <code>formControlName="username" </code></p>
          <p class="card-text">So if you want to use property binding, you can do this by wrapping this in square brackets and then enclosing the username in single quotation marks <code>[formControlName]="'username'"</code> otherwise it would search for a property named username but this is overly complicated, if you just want to pass a string, simply omit the square brackets and you're good to go.</p>
        </div>
      </div>


      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson 203. Reactive: Submitting the Form </h5>
          <p class="card-text"> - </p>
          <p class="card-text">Well we still do the same here because we still want to react to this default submit event which is fired by HTML, by Javascript. So we still add ngSubmit here and we could execute an onSubmit method, any method you like. <code>&#60;form [formGroup]="signupForm" (ngSubmit)="onSubmit()"> </code></p>
          <p class="card-text"> So you can bind it to your own model, the model of your application and easily make sure that the form  structure matches the structure of your model. So this is how you can submit the form, how you can still access the value as you did before but now using your own form, the form you created in TypeScript. </p>
        </div>
      </div>

      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson 204. Reactive: Adding Validation </h5>
          <p class="card-text"> Now that we're able to submit a form, let's actually add some validation to it.  </p>
          <p class="card-text">in the reactive approach because keep in mind and that's key, you're not configuring the form in the template, you're only synchronizing it with the directives, formControlName and formGroup but you're not configuring it here, the TypeScript code, that's where you configure it. That is why FormControl takes more than one argument, this constructor here.<code>routerLink="/servers" </code></p>

          <p class="card-text"> So you can either only pass one validator here, like for username where I only want to make sure that it is required and you do this by adding the validators object, make sure to import it from @angular/forms and there, you get a couple of built-in validators you can use, for example required. <code>'username': new FormControl(null, Validators.required), </code> Now make sure to not call it, to not execute it, so don't have parentheses after it because you don't want to execute this method, it is a static method made available by validators here, instead you only want to pass the reference to this method. Angular will execute the method whenever it detects that the input of this FormControl changed, so it just needs to have a reference on what it should execute at this point of time.</p>
          <p class="card-text">It is possible also to pass an Array of validator  <code>routerLink="/servers" </code></p>


        </div>
      </div>
      <!--
      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson xxx -> </h5>
          <p class="card-text"> - </p>
          <p class="card-text"> <code>routerLink="/servers" </code></p>
        </div>
      </div>
-->





    </div>
  </div>
</div>

